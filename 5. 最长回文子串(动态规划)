class Solution {
public:
    string longestPalindrome(string s) {
        if (s.empty()) return "";
        int len = s.size();
        if (len == 1)return s;
        int longest = 1;
        int start=0;
        vector<vector<int> > dp(len,vector<int>(len));
        for (int i = 0; i < len; i++){
            dp[i][i] = 1;
            if(i<len-1){
                if (s[i] == s[i + 1]){
                    dp[i][i + 1] = 1;
                    start=i;
                    longest=2;
                }
            }
        }
        for (int l = 3; l <= len; l++)//子串长度
        {
            for (int i = 0; i+l-1 < len; i++)//枚举子串的起始点
            {
                int j=l+i-1;//终点
                if (s[i] == s[j] && dp[i+1][j-1]==1){
                    dp[i][j] = 1;
                    start=i;
                    longest = l;
                }
            }
        }
        return s.substr(start,longest);
    }
};

动态规划的方法，我会在下一篇单独来介绍，这里只说明此题的DP代码

 对于字符串str，假设dp[i,j]=1表示str[i...j]是回文子串，那个必定存在dp[i+1,j-1]=1。这样最长回文子串就能分解成一系列子问题，
 可以利用动态规划求解了。首先构造状态转移方程
 





      上面的状态转移方程表示，当str[i]=str[j]时，如果str[i+1...j-1]是回文串，则str[i...j]也是回文串；如果str[i+1...j-1]不是回文串，
      则str[i...j]不是回文串。

      初始状态

dp[i][i]=1
dp[i][i+1]=1 if str[i]==str[i+1]
      上式的意义是单个字符，两个相同字符都是回文串。
      
      
      https://www.cnblogs.com/mini-coconut/p/9074315.html
